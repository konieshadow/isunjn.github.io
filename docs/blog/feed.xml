<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
	<title>isunjn::blog</title>
	<subtitle>The blog of @isunjn</subtitle>
	<link href="https://isunjn.me/blog/feed.xml" rel="self" type="application/atom+xml"/>
    <link href="https://isunjn.me/blog/"/>
	<updated>2022-09-20T00:00:00+00:00</updated>
	<id>https://isunjn.me/blog/feed.xml</id>
	<entry xml:lang="zh-CN">
		<title>读《Effective TypeScript》</title>
		<published>2022-09-20T00:00:00+00:00</published>
		<updated>2022-09-20T00:00:00+00:00</updated>
		<link href="https://isunjn.me/blog/read-effective-ts/" type="text/html"/>
		<id>https://isunjn.me/blog/read-effective-ts/</id>
		<content type="html">&lt;p&gt;《Effective TypeScipt》是一本评价很好的 TS 相关书籍，书中介绍了 62 个类型相关的技巧&#x2F;建议，对理解 TypeScript 的类型系统以及如何应对一些日常开发中会遇到的实际问题很有帮助。
我看的英文版，很易读，和读技术文档差别不大。总之这本书还是很推荐的。&lt;&#x2F;p&gt;
&lt;p&gt;以下是我在读的过程中记的一些要点笔记：&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h3 id=&quot;1-6-getting-to-know-typescript&quot;&gt;1-6: Getting to Know TypeScript&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TS 是 JS 的超集，它保留了大部分 JS 的运行时行为模型，一小部分 JS 允许的行为在 TS 中不被允许，另外一些则可以通过编译器 flag 来控制是否保留&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;TS 的类型系统不是 sound 的，类型不保证正确&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;两个最重要的编译配置：&lt;code&gt;noImplicitAny&lt;&#x2F;code&gt; &lt;code&gt;strictNullChecks&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tsc&lt;&#x2F;code&gt;本身就可以执行‘转译’，生成旧版本的 js 代码&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;类型检查和代码生成是独立的&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;class 同时引入了一个&lt;em&gt;类型&lt;&#x2F;em&gt;和一个&lt;em&gt;值&lt;&#x2F;em&gt;，使得可以在运行时执行类型检查等操作，如&lt;code&gt;instanceof&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;TS 的类型信息只作用于编译时，在运行时被‘擦除’，零运行时开销&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Tagged Union 是一种在运行时引入‘类型’信息的方法&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;TS 的类型系统是&lt;strong&gt;结构化类型&#x2F;鸭子类型&lt;&#x2F;strong&gt;的，TS 中的类型是 open 的，而不是 precise 的，实际的(通过了类型检查的)值可能会有类型声明中没有的属性&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;class 也是结构化的，可以将一个满足某个类型形状的值声明为该 class 类型，但原型链并没有连上&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;结构化类型在测试 mock 的场景中很有用&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;avoid &lt;code&gt;any&lt;&#x2F;code&gt;!&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;7-think-of-types-as-sets-of-values&quot;&gt;7: Think of Types as Sets of Values&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从范畴论的角度来说，类型是值的集合&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;never&lt;&#x2F;code&gt;类型用来表示没有值的集合的类型，即空集，是最小的集合&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;只有一个值的集合所表示的类型也叫单位类型 &#x2F; unit type&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;keyof (A&amp;amp;B) = (keyof A) | (keyof B)&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;keyof (A|B) = (keyof A) &amp;amp; (keyof B)&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;从集合的角度理解&lt;code&gt;extends&lt;&#x2F;code&gt;关键字：某类型的一个子类型，（一个包含在内的、更小的集合）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;tuple 类型的类型信息中还有一个 length 属性，所以&lt;code&gt;[T,T,T]&lt;&#x2F;code&gt;不能赋值给&lt;code&gt;[T,T]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Think of “extends,” “assignable to,” and “subtype of ” as synonyms for “subset of.”&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;8-know-how-to-tell-whether-a-symbol-is-in-the-tyep-sapce-or-value-space&quot;&gt;8: Know How to Tell Whether a Symbol Is in the Tyep Sapce or Value Space&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TS 中的类型标识符和值标识符互不冲突，可以同名&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;class&lt;&#x2F;code&gt;和&lt;code&gt;enum&lt;&#x2F;code&gt;同时引入了一个类型和一个值&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;typeof&lt;&#x2F;code&gt;操作符只能作用于值，但其结果用于类型上下文和值上下文时有不同的意义&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;对&lt;code&gt;class&lt;&#x2F;code&gt;标识符应用&lt;code&gt;typeof&lt;&#x2F;code&gt;的结果取决于上下文&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;typeof&lt;&#x2F;code&gt;、&lt;code&gt;this&lt;&#x2F;code&gt;以及其他许多操作符和关键字在类型和值的上下文中有不同的意义&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;9-prefer-type-declartions-to-type-assertions&quot;&gt;9: Prefer Type Declartions to Type Assertions&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有两种方式给一个值进行类型注解：&lt;code&gt;const val: Person = {}&lt;&#x2F;code&gt; &lt;code&gt;const cal = {} as Person&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;尽可能使用类型声明而不是类型断言&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;仅在确定自己比 type checker 有更多的类型信息时才使用类型断言，通常是在和外部系统交互时&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;!&lt;&#x2F;code&gt;非空断言也是类型断言，同样应该在自己拥有更多信息时才使用&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;通过类型断言进行的类型转换不是任意的，仅当其中一个是另一个的子集时才可以，&lt;code&gt;unkown&lt;&#x2F;code&gt;类型是任意类型的子集&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;通过注解箭头函数的返回值来进行类型声明：&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;const people = [&#x27;alice&#x27;, &#x27;bob&#x27;].map((ame): Person =&amp;gt; ({ name }));&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;10-avoid-object-wrapper-types&quot;&gt;10: Avoid Object Wrapper Types&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;11-recognize-the-limits-of-excess-prperty-checking&quot;&gt;11: Recognize the Limits of Excess Prperty Checking&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;尽管是结构化类型系统，Ts 提供了“excess propety checking”检测来帮助发现错误，它作用于对象字面量，（这意味着如果先把对象字面量赋值给一个变量，再用这个变量的话就不会触发该检查）&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果不想要这种检查，可以在类型声明中加上 index signature&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;另一个在结构化类型系统之外的检查发生在 weak type 上，指的是那些全部属性均是 optional 的类型，TS 检查值类型和声明类型至少有一个共同属性，这个检查作用于所有赋值，而不仅仅是字面量&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;这两种检查均是在结构化类型对可赋值性检查之外的检查，有助于帮助发现 typo 和其他一些涉及属性名的错误，在类型有可选字段时尤其有用&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;12-apply-types-to-entire-function-expressions-when-possible&quot;&gt;12: Apply Types to Entire Function Expressions When Possible&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;考虑对整个函数表达式应用一个类型注解，而不是对参数和返回值进行注解&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;const fn: XxxFn = (param) =&amp;gt; returned;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果有多个函数的类型注解相同，考虑这种方式来减少重复，另一个好处是使逻辑意图更加显式&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果是库作者，考虑对常见 callback 提供整个函数的类型&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;typeof fn&lt;&#x2F;code&gt;来得到另一个函数的类型来使用&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;13-know-the-differences-between-type-and-interface&quot;&gt;13: Know the Differences Between type and interface&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;总体上 type 比 interface 更加强大，尤其是涉及到 union type 时，元组和数组类型用 type 也更容易表达&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;interface 相比 type 的优点在于它可以被&lt;em&gt;增强&lt;&#x2F;em&gt;，interface 可以通过&lt;em&gt;声明合并&lt;&#x2F;em&gt;的方式来增加字段，如果不希望用户增加字段，则用 type&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如何选择：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;复杂类型如 union 只能用 type&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果是简单的类型，考虑两点：风格一致性、是否希望增强&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果类型是要对外可见&#x2F;发布的，用户可能会希望能够增强它，prefer interface&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果类型仅仅是内部使用，声明合并通常不是希望的，prefer type&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;14-use-type-operations-and-generics-to-avoid-repeating-yourself&quot;&gt;14: Use Type Operations and Generics to Avoid Repeating Yourself&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;DRY 也同样应该应用在类型方面，类型上的重复更加常见，因为人们不熟悉为减少类型重复而采用的模式&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;最简单的减少重复的方式：命名你的类型，这类似于在代码中提取一个常量而不是到处重复形成魔数，函数类型同样适用，将签名相同的函数的类型提取出来&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果两个类型有相同的部分字段，可以尝试提取出一个基类，然后 extends&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;相反，如果要使用一个基类型的某几个字段来定义一个衍生类型，可以使用索引该基类型的方式来定义：&lt;code&gt;type TopNavState = { userId: State[&#x27;userId&#x27;]; title: State[&#x27;title&#x27;]; }&lt;&#x2F;code&gt;，使用映射类型来进一步减少重复：&lt;code&gt;type TopNavState = { [k in &#x27;userId&#x27; | &#x27;title&#x27;]: State[K] }&lt;&#x2F;code&gt;,这类似于代码中的通过循环减少重复，标准库对此常见模式有支持，那就是&lt;code&gt;type Pick&amp;lt;T, K extends keyof T&amp;gt; = { [k in K]: T[k] };&lt;&#x2F;code&gt;，上面例子改写成：&lt;code&gt;type TopNavState = Pick&amp;lt;State, &#x27;userId&#x27; | &#x27;title&#x27;&amp;gt;&lt;&#x2F;code&gt;，使用 pick 这样的泛型类型类似于调用一个函数&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;提取 Tagged Union 类型的 tag 时使用类型字段索引，而不是重复书写 &lt;code&gt;type ActionType = Action[&#x27;type&#x27;]; &#x2F;&#x2F; &#x27;save&#x27; | &#x27;load&#x27; | &#x27;...&#x27;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;type OptionsUpdate = { [K in keyof Options]?: Option[K] };&lt;&#x2F;code&gt; 标准库提供&lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果要从一个值生成类型，使用&lt;code&gt;typeof&lt;&#x2F;code&gt;，但是通常是先有类型再有值&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;type ReturnedT = ReturnType&amp;lt;typeof XxxFn&amp;gt;;&lt;&#x2F;code&gt;，同样应当小心使用&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;code&gt;extends&lt;&#x2F;code&gt;关键字来对泛型参数进行约束&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;15-use-index-signatures-for-dynamic-data&quot;&gt;15: Use Index Signatures for Dynamic Data&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;索引签名用在动态数据的场景中，例如解析 CSV，列名提前不知道&lt;code&gt;{ [columnName: string]: string }[]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;动态数据没有保证，考虑对值的类型曾加一个 undefined 来确保使用之前进行运行时检查&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果提前知道字段信息，使用该信息而不是索引签名，可以用可选字段或 union 的形式&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果使用 string 来作为索引键的类型太广的话，考虑：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Record，例如如&lt;code&gt;Record&amp;lt;&#x27;x&#x27; | &#x27;y&#x27;, number&amp;gt;&lt;&#x2F;code&gt;，键类型降到 string 的一个子集&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Mapped Type，可以在 Record 的基础上对不同的键指定不同的类型：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;type Vec3D = { [k in &#x27;x&#x27; | &#x27;y&#x27; | &#x27;z&#x27;]: number }&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;type ABC = { [k in &#x27;a&#x27; | &#x27;b&#x27;]: k extends &#x27;b&#x27; ? string : number }&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;16-prefer-arrays-tuples-and-arraylike-to-number-index-signatures&quot;&gt;16: Prefer Arrays, Tuples, and ArrayLike to number Index Signatures&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数组的索引在运行时实际上也是 string 类型的，但 TS 将其类型声明为 number，有助于帮助发现错误，number index signatures 仅仅是一个 TS 构造&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;As a general rule, there’s not much reason to use number as the index signature of a type rather than string. If you want to specify something that will be indexed using numbers, you probably want to use an Array or tuple type instead.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;标准库提供&lt;code&gt;ArrayLike&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;类型，只有 length 属性和 number index signature&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;17-use-readonly-to-avoid-errors-associated-with-mutation&quot;&gt;17: Use readonly to Avoid Errors Associated with Mutation&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;number[]&lt;&#x2F;code&gt;是&lt;code&gt;readonly number[]&lt;&#x2F;code&gt;的子类型（而不是反过来），所以&lt;code&gt;number[]&lt;&#x2F;code&gt;类型的值可以被赋值给&lt;code&gt;readonly number[]&lt;&#x2F;code&gt;类型的变量，反过来则不行&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果函数有不改变参数的值的规约的话，应当对参数的类型加上&lt;code&gt;readonly&lt;&#x2F;code&gt;修饰符&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;readonly&lt;&#x2F;code&gt;在类型层面上指定值的内容不能修改，变量的指向能否更改仍然由&lt;code&gt;let&#x2F;const&lt;&#x2F;code&gt;控制&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;readonly&lt;&#x2F;code&gt; is shallow&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;18-use-mapped-types-to-keep-values-in-sync&quot;&gt;18: Use Mapped Types to Keep Values in Sync&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果你想要一个对象有和另一个对象完全一致的属性，使用 mapped types&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;保持同步：如果对象的每个属性都对应一个类似 flag 的东西，添加属性时需要同步更新 flag，考虑使用 mapped type 来增加一个值，这样修改后如果忘记更新会报类型错误，这样就强制了同步这个操作&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;const REQUIRES_UPDATE: {[k in keyof ScatterProps]: boolean} = {xs:true, xy: true onClick:false};&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;19-avoid-cluttering-your-code-with-inferable-types&quot;&gt;19: Avoid Cluttering Your Code with Inferable Types&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;手动注解可以被推断的类型总体上不被推荐&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;函数签名，包括参数和返回值最好进行类型注解，函数体内的本地变量最好不注解&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果函数参数有默认值，这时该参数的类型注解也应当省略&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果函数是作为回调来使用，通常已经在那里被注解了，因此此时不需要再显式注解&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;对象字面量可以被 infer 出来，但最好显式注解一个命名类型，这还会触发 excess property checking&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;函数返回值类似，能够被 infer，但最好显式注解&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;20-use-different-variables-for-different-types&quot;&gt;20: Use Different Variables for Different Types&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;丢弃 js 的动态类型特性&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;增加变量来表示不同的类型语义，而不是重用同一个变量去改变它的类型，有很多好处&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;更加语义化，不同的变量可以区分出不同的语义，更加具体的变量命名&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;有助于使用类型推断，而不是显式类型注解&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;更简单的类型，而不是 union&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;使用 const 而不是 let&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;21-understand-type-widening&quot;&gt;21: Understand Type Widening&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类型扩展发生在 ts 尝试通过赋值给变量的值来推断变量的类型时&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;使用 const 而不是 let 来定义变量就可以阻止变量通过之后的赋值去扩展类型范围&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;通过显式类型注解、更多的上下文信息、&lt;code&gt;as const&lt;&#x2F;code&gt;等方式来阻止类型猜测&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;22-understand-type-narrowing&quot;&gt;22: Understand Type Narrowing&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TS 通过条件判断和控制流分析来进行类型收缩&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;使用 tagged&#x2F;discriminated union 来帮助进行类型收缩&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;使用自定义类型谓词函数来在 map&#x2F;filter&#x2F;reduce 等地方进行类型收缩&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;23-create-objects-all-at-once&quot;&gt;23: Create Objects All at Once&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;prefer creating objects all at once, rather than piece by piece&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;...&lt;&#x2F;code&gt;操作符来一次性构造出对象：&lt;code&gt;const point = {...pt, ...id}&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果必须分步骤构建，尝试引入中间变量，这样最后的变量可以一次给对&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果要条件地添加一个属性，需要使用一个辅助函数 &lt;code&gt;p98&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;24-be-consisitent-in-your-use-of-aliases&quot;&gt;24: Be Consisitent in Your Use of Aliases&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;这里的 alias 指引用同一个对象的多个变量，会引入不一致&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;if you introduce an alias, use it consistently&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;使用解构语法来防止给一个属性不同的名字&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;对一个值进行的某个属性信息类型判断后，在这个值之上的函数调用可能会更改这个属性，但 ts 控制流分析不会重新验证去反映出这个变化&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;25-use-async-functions-instead-of-callbacks-for-asynchronous-code&quot;&gt;25: Use async Functions Instead of Callbacks for Asynchronous Code&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Promise.race()&lt;&#x2F;code&gt;返回值的类型是各个 promise 的类型的 union&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;prefer &lt;code&gt;async&#x2F;await&lt;&#x2F;code&gt; to raw promises&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;异步函数总是返回 promise&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;一个函数应当总是被同步地调用或总是被异步地调用，而不是混用，异步函数可以强制保证这一点，回调和原生 promise 容易导致半异步的函数&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果一个函数返回一个 promise，将其声明为 async&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;26-understand-how-context-is-used-in-type-inference&quot;&gt;26: Understand How Context Is Used in Type Inference&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;值所在的上下文会影响类型推断，一些在 JS 中结果相同的写法在 TS 中可能导致推断出不同的类型&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;TS 在一个值最初被引入时即确定其类型，而不是根据其最终被使用时的上下文，这就可能导致推断出的类型跟最终被使用时希望的类型不一致，例如&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 let 声明的字符串的类型是 string，使用时期待的类型是 literal&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;定义字面量数组时其类型为数组而不是元组，这时应当使用显式类型注解或&lt;code&gt;as const&lt;&#x2F;code&gt;，注意&lt;code&gt;as const&lt;&#x2F;code&gt;还会加上&lt;code&gt;readonly&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;设计字面量和元组的对象也有相同的问题，同样使用显式类型注解或&lt;code&gt;as const&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;27-use-functional-constructs-and-libraries-to-help-types-flow&quot;&gt;27: Use Functional Constructs and Libraries to Help Types Flow&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函数式风格的库&#x2F;构件的 TS 类型声明天然使得类型 flow through&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;使用内置的函数式构件和第三方函数式类库来增强类型流，增加易读性，减少显式类型注解&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;28-prefer-types-that-always-represent-valid-states&quot;&gt;28: Prefer Types That Always Represent Valid States&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;保持状态总是&lt;em&gt;有效&#x2F;合法&lt;&#x2F;em&gt;状态，设计良好的状态能表达出的所有组合都是合理&#x2F;有效的&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;29-be-liberal-in-what-you-accept-and-strict-in-what-you-produce&quot;&gt;29: Be Liberal in What You Accept and Strict in What You Produce&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参数类型可以更 open 一些，有多种不同的形式，这样函数用起来更&lt;em&gt;方便&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;返回值类型需要更加精确，应当只有一种形状&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;可以为参数和返回值设计相关但又不同的类型，一种更规范，用于返回值，一种更宽松，用于参数&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;30-don-t-repeat-type-information-in-documentation&quot;&gt;30: Don’t Repeat Type Information in Documentation&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;避免在文档和变量名中重复类型信息&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;单位信息如果不能通过类型表达出来的话，可以加在变量名中&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;31-push-null-values-to-the-perimeter-of-your-types&quot;&gt;31: Push Null Values to the Perimeter of Your Types&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;返回一整个完全不为空的对象或者 null，而不是多个相互关联的可能为 null 可能不为 null 的值&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;考虑将类的字段声明为都不为 null，然后用一个静态方法去拿到所有值后再去构造，而不是以 null 作为初始值去构造&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;32-prefer-unions-of-interfaces-to-interfaces-of-unions&quot;&gt;32: Prefer Unions of Interfaces to Interfaces of Unions&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果一个类型的多个属性都是 union，通常是错误的抽象，会导致非法状态的出现&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;If you can represent a data type in TypeScript with a tagged union, it’s usually a good idea to do so&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;33-prefer-more-precise-alternatives-to-string-types&quot;&gt;33: Prefer More Precise Alternatives to String Types&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Avoid “stringly typed”&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;命名类型还可以用&lt;code&gt;&#x2F;** *&#x2F;&lt;&#x2F;code&gt;来加文档注释&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;34-prefer-incomplete-types-to-inaccurate-types&quot;&gt;34: Prefer Incomplete Types to Inaccurate Types&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;增加类型精确性的同时也导致出现不正确的可能性增大&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;避免过于精确的类型导致使用&#x2F;理解起来过去复杂，尽量避免导致自动补全失效的改动&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;35-generate-types-from-apis-and-sepcs-not-data&quot;&gt;35: Generate Types from APIs and Sepcs, Not Data&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;避免从样例数据生成类型&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;36-name-types-using-the-language-of-your-problem-domain&quot;&gt;36: Name Types Using the Language of Your Problem Domain&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;避免不恰当的命名&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;37-consider-brands-for-nominal-typing&quot;&gt;37: Consider “Brands” for Nominal Typing&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TS 中让类型变为 Nonminal Type 的方式是为类型增加一个独特的标记字段，称为&lt;code&gt;brand&lt;&#x2F;code&gt;，这会引入运行时开销&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;也可以仅在类型层面上使用这些标记，还可以将内置类型变为 nominal 的，需要结合类型谓词&#x2F;断言来使用，结合运行时的断言，可以做到类型系统原本无法做到的一些事&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;38-use-the-narrowest-possible-scope-for-any-types&quot;&gt;38: Use the Narrowest Possible Scope for &lt;code&gt;any&lt;&#x2F;code&gt; Types&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;需要类型强转的时候使用&lt;code&gt;as any&lt;&#x2F;code&gt;而不是将类型注解改为&lt;code&gt;any&lt;&#x2F;code&gt;，这样不会把变量在其他地方也搞成&lt;code&gt;any&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;永远不要将返回类型声明为&lt;code&gt;any&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;39-prefer-more-precise-variants-of-any-to-plain-any&quot;&gt;39: Prefer More Precise Variants of &lt;code&gt;any&lt;&#x2F;code&gt; to Plain &lt;code&gt;any&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;any[]&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;{[key: string]: any}&lt;&#x2F;code&gt; &lt;code&gt;Record&amp;lt;string, any&amp;gt;&lt;&#x2F;code&gt; &lt;code&gt;object&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;() =&amp;gt; any&lt;&#x2F;code&gt; &lt;code&gt;(...args: any[]) =&amp;gt; any&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;40-hide-unsafe-type-assertions-in-well-typed-functions&quot;&gt;40: Hide Unsafe Type Assertions in Well-Typed Functions&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有一些函数的签名是类型安全的，但具体实现较难做到完全类型安全&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;可以考虑将不安全的类型断言操作隐藏在一个签名类型正确的函数内部&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;41-understand-evolving-any&quot;&gt;41: Understand Evolving &lt;code&gt;any&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果一个变量根据初始赋值被推断为&lt;code&gt;any&lt;&#x2F;code&gt;，会根据后续使用情况变推断成更具体的类型&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;最好还是显式地进行类型注解&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;42-use-unknown-instead-of-any-for-values-with-an-unknown-type&quot;&gt;42: Use &lt;code&gt;unknown&lt;&#x2F;code&gt; Instead of &lt;code&gt;any&lt;&#x2F;code&gt; for Values with an Unknown Type&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;unknown&lt;&#x2F;code&gt;是一个比&lt;code&gt;any&lt;&#x2F;code&gt;更类型安全的类型，如果不知道值的类型，最好用&lt;code&gt;unknown&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;unknown&lt;&#x2F;code&gt;可以强制值的使用者去做类型断言或运行时类型检查&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;{}&lt;&#x2F;code&gt; &lt;code&gt;object&lt;&#x2F;code&gt; &lt;code&gt;unknown&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;43-prefer-type-safe-approaches-to-monkey-patching&quot;&gt;43: Prefer Type-Safe Approaches to Monkey Patching&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;尽可能避免在全局对象&#x2F;宿主环境对象上加属性这种操作&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果避免不了，可以用 interface 的声明合并功能，或 extends 出一个更具体的类型然后再断言&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;44-track-your-type-coverage-to-prevent-regressions-in-type-safety&quot;&gt;44: Track Your Type Coverage to Prevent Regressions in Type Safety&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;npx type-coverage&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;45-put-typescript-and-types-in-devdependencies&quot;&gt;45: Put TypeScript and @types in devDependencies&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;46-understand-the-three-versions-involved-in-type-declarations&quot;&gt;46: Understand the Three Versions Involved in Type Declarations&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;依赖管理涉及到的版本问题：包本身，包类型声明(@types)，TSC&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;type 的 patch 版本可以比包本身的高&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;确保更新库时同步更新相应的@types&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;如果库本身就是用 TS 写的，可以将类型声明和库一起打包，虽然也可能有一些问题；如果不是，最好是用 DefinitelyTyped 来维护&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;47-export-all-types-that-appear-in-public-apis&quot;&gt;47: Export All Types That Appear in Public APIs&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;虽然一些出现在 API 中但没有显式导出的类型可以被库的用户手动提取出来，但最好还是将这些类型都显式地导出比较好&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;48-use-tsdoc-for-api-comments&quot;&gt;48: Use TSDoc for API Comments&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&#x2F;** *&#x2F;&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@param&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@return&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;TS 就不要再加&lt;code&gt;{type}&lt;&#x2F;code&gt;了&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;支持 markdown&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;避免过于 verbose&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;49-provide-a-type-for-this-in-callbacks&quot;&gt;49: Provide a Type for &lt;code&gt;this&lt;&#x2F;code&gt; in Callbacks&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;如果作为 API 的回调函数中限制了 this 的值&#x2F;类型，需要在函数签名中指定 this 的类型&lt;code&gt;this: XXXType&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;50-prefer-conditional-types-to-overloaded-declarations&quot;&gt;50: Prefer Conditional Types to Overloaded Declarations&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;function double&amp;lt;T extends number | string&amp;gt;(x: T): T extends string ? string : number {...}&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Conditional types distribute over unions&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;51-mirror-types-to-sever-dependencies&quot;&gt;51: Mirror Types to Sever Dependencies&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Don’t force JS users to depend on @types, Don’t force web developers to depend on NodeJS&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;可以利用结构化类型将第三方库的类型 mirror 成自己的&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;52-be-aware-of-the-pitfalls-of-testing-types&quot;&gt;52: Be Aware of the Pitfalls of Testing Types&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;测试类型时注意 equality 和 assignability 的区别&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;使用 dtslint 之类的工具&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;53-prefer-ecmascript-features-to-typescript-features&quot;&gt;53: Prefer ECMAScript Features to TypeScript Features&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TS 的部分功能是为了弥补 JS 的缺失，随着 JS 的发展，其中一些不再需要了，现在应该仅将 TS 定位在 type 层面上来使用，避免使用 enum 等&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;prefer 使用字面量 union 来作为枚举&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;parameter preoerties 会生成一些运行时代码&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;使用 ES 模块，而不是 namespace 和三斜杠引用&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;装饰器仍然未稳定，尝试避免使用&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;54-know-how-to-iterate-over-objects&quot;&gt;54: Know How to Iterate Over Objects&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;let k: keyof T&lt;&#x2F;code&gt;&amp;amp;&lt;code&gt;for-in&lt;&#x2F;code&gt; 当对象属性已知时，注意这种方式可能产生运行时错误，比如实际对象包含类型声明之外的属性、对象原型链上有可枚举的属性&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Object.entries()&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;55-understand-the-dom-hierarchy&quot;&gt;55: Understand the DOM hierarchy&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EventTarget -&amp;gt; Node -&amp;gt; Element -&amp;gt; HTMLElement -&amp;gt; HTMLBUttonElement&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;56-don-t-rely-on-private-to-hide-information&quot;&gt;56: Don’t Rely on Private to Hide Information&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;private&lt;&#x2F;code&gt;仅仅是一个类型层面的约束，不要过于依赖&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;57-use-source-maps-to-debug-typescript&quot;&gt;57: Use Source Maps to Debug TypeScript&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;“sourceMap”: true&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;58-write-modern-javascript&quot;&gt;58: Write Modern JavaScript&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;tsc 会执行转译，尽量用最新的 JS 特性&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;59-use-ts-check-and-jsdoc-to-experiment-with-typescript&quot;&gt;59: Use @ts-check and JSDoc to Experiment with Typescript&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@ts-check&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;不要纠结于把 JSDoc 全写对，目标应该是转成 TS 文件&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;60-use-allowjs-to-mix-typescript-and-javascript&quot;&gt;60: Use allowJs to Mix TypeScript and JavaScript&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;allowJs&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;61-convert-module-by-module-up-your-dependency-graph&quot;&gt;61: Convert Module by Module Up Your Dependency Graph&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个模块一个模块来&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;首先是第三方依赖模块，@types&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;从依赖图的底层开始向上依次进行&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;62-don-t-condider-migration-complete-until-you-enable-noimplicitany&quot;&gt;62: Don’t Condider Migration Complete Until You Enable noImplicitAny&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;将所有隐式 any 去除后才算完全转到 TS&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="zh-CN">
		<title>用 TypeScript 实现 SNL 编译器前端</title>
		<published>2022-04-30T00:00:00+00:00</published>
		<updated>2022-04-30T00:00:00+00:00</updated>
		<link href="https://isunjn.me/blog/snl-compiler-in-ts/" type="text/html"/>
		<id>https://isunjn.me/blog/snl-compiler-in-ts/</id>
		<content type="html">&lt;p&gt;SNL (Small Nested Language) 是我校用于教学的一个非常简单(且不完整)的&amp;quot;高级&amp;quot;编程语言, 编译原理的课设就是实现它的编译器前端部分, 我试着用 TypeScript 完成了这个任务, 整体做下来感觉难度不大，确实是个玩具语言的玩具编译器，这里简单记录一下实现过程。&lt;&#x2F;p&gt;
&lt;p&gt;项目地址: &lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;isunjn&#x2F;snlc&quot;&gt;https:&#x2F;&#x2F;github.com&#x2F;isunjn&#x2F;snlc&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;note info&quot;&gt;
    &lt;i class=&quot;ri-information-line ri-lg&quot;&gt;&lt;&#x2F;i&gt;
    &lt;div class=&quot;content&quot;&gt;
        
        &lt;p&gt;本文假设读者对 TypeScript 以及编译原理的相关概念有基本的了解&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
&lt;&#x2F;blockquote&gt;&lt;h2 id=&quot;snl-yu-yan&quot;&gt;SNL 语言&lt;&#x2F;h2&gt;
&lt;p&gt;这是一个长得基本和 Pascal 一样的过程式语言。变量先声明再使用，数据类型支持整型、字符型、数组、记录，过程允许嵌套定义，允许递归调用。作为一个教学用的简易语言，SNL 有非常大的局限性，比如不支持布尔类型和逻辑运算（但比较表达式实际上会产生一个布尔型的值）、条件表达式必须有 else 块且至少一条语句、字符型仅能声明而不能对其赋值……尽管如此，它仍然“具备高级程序设计语言的常见特征”，至少教材上它自己是这么说 :）&lt;&#x2F;p&gt;
&lt;p&gt;一段简单的 SNL 代码：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2e3440;color:#d8dee9;&quot;&gt;&lt;code&gt;&lt;span&gt;program p
&lt;&#x2F;span&gt;&lt;span&gt;type
&lt;&#x2F;span&gt;&lt;span&gt;    t = integer;
&lt;&#x2F;span&gt;&lt;span&gt;var
&lt;&#x2F;span&gt;&lt;span&gt;    t i, j, k;
&lt;&#x2F;span&gt;&lt;span&gt;    char ch;
&lt;&#x2F;span&gt;&lt;span&gt;    array [1..20] of integer arr;
&lt;&#x2F;span&gt;&lt;span&gt;procdure
&lt;&#x2F;span&gt;&lt;span&gt;    fn(integer num);
&lt;&#x2F;span&gt;&lt;span&gt;    begin
&lt;&#x2F;span&gt;&lt;span&gt;        return(num + 1)
&lt;&#x2F;span&gt;&lt;span&gt;    end
&lt;&#x2F;span&gt;&lt;span&gt;begin
&lt;&#x2F;span&gt;&lt;span&gt;    read(i);
&lt;&#x2F;span&gt;&lt;span&gt;    j := i + k;
&lt;&#x2F;span&gt;&lt;span&gt;    fn(j * arr[1])
&lt;&#x2F;span&gt;&lt;span&gt;end.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;你还可以看下 &lt;code&gt;sample&#x2F;&lt;&#x2F;code&gt; 文件夹下的其他几个代码示例，以及 &lt;code&gt;docs&#x2F;snl.bnf&lt;&#x2F;code&gt; （注意该文件并没有按照严格的 BNF 格式书写）&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ci-fa-fen-xi&quot;&gt;词法分析&lt;&#x2F;h2&gt;
&lt;p&gt;编译器的第一个组件是词法分析器（lexer），这个阶段会去除掉源代码（字符序列）的注释和空白符，并将各种字符序列转换成为称之为 Token 的表示形式，得到一个 Token List。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dfa&quot;&gt;DFA&lt;&#x2F;h3&gt;
&lt;p&gt;词法分析的主要依据是该语言的词法 DFA，通过 DFA 判断某段字符序列是否合法、如果合法的话具体是哪种词法元素。&lt;&#x2F;p&gt;
&lt;p&gt;SNL 的 DFA：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;isunjn&#x2F;isunjn.github.io&#x2F;img&#x2F;202205021124104.png&quot; alt=&quot;SNL DFA&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;每个状态会根据当前字符进行判断，是转到另一个状态，还是生成一个 Token，还是出错（图中省略了出错状态）。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;token&quot;&gt;Token&lt;&#x2F;h3&gt;
&lt;p&gt;具体到代码实现，我们需要先定义一下 Token 的数据结构。见 &lt;code&gt;src&#x2F;common&#x2F;token.ts&lt;&#x2F;code&gt;，它有四个字段，分别是行号、列号、词法类型（lex）、语义信息（sem）。每个关键字算作一种单独的词法类型，用它的大写表示。并非所有 Token 都有语义信息，标识符、整型、字符型需要记录他们具体的值作为其语义信息，其他 Token 则不需要语义信息部分。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ci-fa-fen-xi-de-shi-xian&quot;&gt;词法分析的实现&lt;&#x2F;h3&gt;
&lt;p&gt;见 &lt;code&gt;src&#x2F;lexer.ts&lt;&#x2F;code&gt;，我们给 DFA 中的每个状态写一个函数，处理该状态内部的情况，这些状态处理函数的参数是当前正在处理的字符和一个将来可能会用作语义信息的字符数组，返回值是另一个状态处理函数（的引用）或者一个 Token 或者一个词法错误。&lt;&#x2F;p&gt;
&lt;p&gt;lexer 函数会对全局变量进行初始化并调用 tokenizer，tokenizer 负责每次完成一个 Token 的解析，返回一个 Token 或一个 LexError。（其实 tokenizer 也是词法分析器的意思，和 lexer 是同义词，不过用在这里表示识别一个 Token 好像也说得过去）&lt;&#x2F;p&gt;
&lt;p&gt;词法分析要考虑的点：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;字符有时需要“向前看”，当读入下一个字符并判断后可能需要进行回退（goBack），回退时需要考虑好行号和列号的变化&lt;&#x2F;li&gt;
&lt;li&gt;注释和空白也作为 Token 返回，但并不加入最终的 Token List&lt;&#x2F;li&gt;
&lt;li&gt;标识符判定时需要判断是否是语言关键字&lt;&#x2F;li&gt;
&lt;li&gt;根据所处状态进行相应的错误处理（我这里的实现并没有考虑到错误恢复，可能会导致错误连环出现）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;yu-fa-fen-xi&quot;&gt;语法分析&lt;&#x2F;h2&gt;
&lt;p&gt;词法分析完成后，（如果没有词法错误）我们就得到了源程序的 Token List，可以进行下一步的语法分析了。&lt;&#x2F;p&gt;
&lt;p&gt;语法分析根据语言的文法规则对 Token 序列进行解析（parse)，生成一颗抽象语法树（Abstract Syntax Tree，AST），或产生语法错误（SyntaxError）。&lt;&#x2F;p&gt;
&lt;p&gt;语言的文法规则是定义好了的，用若干条产生式表示，教材里 SNL 有 104 条产生式，见 &lt;code&gt;docs&#x2F;snl.bnf&lt;&#x2F;code&gt;。这些规则定义了源码中的 Token 序列能以怎样的方式排列起来（即满足语法要求）。&lt;&#x2F;p&gt;
&lt;p&gt;语法分析分为自顶向下分析和自底向上分析，自顶向下又分为递归向下法和 LL(1) 分析法，因为课设要求自顶向下的这两种方法都要做，所以这里实现了两个 parser。&lt;&#x2F;p&gt;
&lt;p&gt;语法分析的相关原理限于篇幅我在这里就不赘述了，只讲一下具体代码实现。&lt;&#x2F;p&gt;
&lt;p&gt;我们首先定义一下描述文法时需要用到的终结符和非终结符类型，请查看 &lt;code&gt;src&#x2F;common&#x2F;grammar.ts&lt;&#x2F;code&gt;，定义文法规则为 &lt;code&gt;Rule&lt;&#x2F;code&gt;，将 104 条规则保存到一个 Map 中，称为 &lt;code&gt;grammar&lt;&#x2F;code&gt;，通过规则的序号来索引。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;predict-ji&quot;&gt;Predict 集&lt;&#x2F;h3&gt;
&lt;p&gt;递归下降法会用到产生式的预测集，当文法中出现一个非终结符有多条产生式的情况时需要根据各产生式的预测集进行下一步动作，LL(1) 分析法也会用到根据预测集构造的预测表。&lt;&#x2F;p&gt;
&lt;p&gt;因为产生式是给定了的，所以实际上预测集也是不变的，可以提前手工计算出来，教材里也是直接给出了（不过教材里的预测集是有错的，话说这教材写得&lt;del&gt;还真是烂呀&lt;&#x2F;del&gt;还真是给了同学们很大的发挥空间）&lt;&#x2F;p&gt;
&lt;p&gt;因为这个玩具项目的主要目的还是学习编译原理，我们实现一遍预测集生成算法也无妨，这里我参考 &lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;LL_parser&quot;&gt;LL parser - Wikipedia&lt;&#x2F;a&gt; 里关于 LL(1) 分析表的算法描述，实现了预测集和预测表的生成，见 &lt;code&gt;src&#x2F;common&#x2F;predict.ts&lt;&#x2F;code&gt;，导出的两个函数分别被两个 parser 使用。&lt;&#x2F;p&gt;
&lt;p&gt;这种预测集 “generated on the fly” 的方式其实是不太合理的，没有必要每次编译都重新进行一遍这样结果已经确定的计算，特别是编译器这种性能敏感型程序。这里主要是出于学习目的。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ast-ding-yi&quot;&gt;AST 定义&lt;&#x2F;h3&gt;
&lt;p&gt;我们还需要知道语法分析的输出具体是什么，为此我们需要定义抽象语法树的结构，而抽象语法树节点的数据结构定义可能是整个项目最大的难点了。&lt;&#x2F;p&gt;
&lt;p&gt;教材在这里用了一种很奇葩的方式，它将所有不同类型的树节点的字段全部 union 到一个结构体里，再根据类型字段判断哪几个数据字段是有效的……不嫌浪费内存吗.jpg ，正确的做法应该是为每种节点定义一个类型。&lt;&#x2F;p&gt;
&lt;p&gt;SNL 的 AST 有这几种节点：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;标识符和整形字面量（没有字符型，因为 SNL 实际上并不支持字符型……）&lt;&#x2F;li&gt;
&lt;li&gt;根节点，包含程序名、声明部分、程序体部分&lt;&#x2F;li&gt;
&lt;li&gt;声明部分，包含类型声明部分、变量声明部分、过程声明部分（过程声明中还包含参数声明部分）&lt;&#x2F;li&gt;
&lt;li&gt;语句，分为条件语句、循环语句、赋值语句、写语句、读语句、返回语句&lt;&#x2F;li&gt;
&lt;li&gt;表达式，分为操作符表达式、常量表达式、标识符表达式（变量表达式）&lt;&#x2F;li&gt;
&lt;li&gt;变量相关节点&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;节点的具体定义请见 &lt;code&gt;src&#x2F;common&#x2F;ast.ts&lt;&#x2F;code&gt;，这里的类型定义使用了 TypeScript 的 type 而不是 JavaScript 的 class，为此需要考虑如何新建节点的问题。因为我们的节点定义里大部分字段的类型并非可为 null 的类型，但后面新建节点时却又需要它暂时为 null，因为在新建时可能还没有字段的具体值，也许应该将其定义为类似 Rust 中的 Option 类型的东西，但这些字段在概念上又确实不为空，所以并不合适，我这里的解决办法是定义了一个 Nullable 泛型，将一个对象类型的所有字段变为可为 null，这样在新建节点时创建目标类型的 Nullable 类型，然后等字段全部赋值后再进行一次类型断言，转为非空类型。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ts&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-ts &quot;&gt;&lt;code class=&quot;language-ts&quot; data-lang=&quot;ts&quot;&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;type Nullable&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbcbb;&quot;&gt;T&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;{ [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbcbb;&quot;&gt;P &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;in keyof &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbcbb;&quot;&gt;T&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbcbb;&quot;&gt;T&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbcbb;&quot;&gt;P&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbcbb;&quot;&gt;null &lt;&#x2F;span&gt;&lt;span&gt;}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;通过 createNode 函数来新建一个 &lt;code&gt;NullableNode&amp;lt;T&amp;gt;&lt;&#x2F;code&gt;，根据 kind 参数的值来新建具体的类型。&lt;&#x2F;p&gt;
&lt;p&gt;这样处理确实能用，但感觉不太优雅，代码看起来也比较怪，也许将每一个类型定义为 class 然后写构造函数会更好一点，我的 TS 水平还有待提高 😢&lt;&#x2F;p&gt;
&lt;p&gt;还有我们的语法分析实现并没有考虑错误恢复，每次识别到一个错误就会停止继续解析，局限性很大。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;di-gui-xia-jiang-jie-xi&quot;&gt;递归下降解析&lt;&#x2F;h3&gt;
&lt;p&gt;现在有了 AST 的定义，可以进行具体的语法分析了，先来看看更加直观的递归下降法。&lt;&#x2F;p&gt;
&lt;p&gt;所谓递归下降法，说的是为每一个非终结符写一个子程序，处理其产生式右部，终结符则进行匹配，非终结符则递归调用该非终结符的处理子程序。&lt;&#x2F;p&gt;
&lt;p&gt;很容易可以写出这样的代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ts&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-ts &quot;&gt;&lt;code class=&quot;language-ts&quot; data-lang=&quot;ts&quot;&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;function &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;parseXX&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#d8dee9;&quot;&gt;node &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;createNode&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;XX&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#d8dee9;&quot;&gt;currentToken &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;getNext&lt;&#x2F;span&gt;&lt;span&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(currentToken&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;lex &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;!= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;XXX&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;throw new &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbcbb;&quot;&gt;SyntaxError&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;Expect a XXX&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        node&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;xxx &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#616e88;&quot;&gt;&#x2F;* somthing generated based on currentToken *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#616e88;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后得为每个非终结符都写上一个这样的函数，属于是累活了。&lt;&#x2F;p&gt;
&lt;p&gt;不过仔细观察我们会发现&amp;quot;拿到下一个 Token，判断是否匹配或是否落入预测集，成功则生成相应值，失败则出错&amp;quot;这样的代码逻辑在每一个 parseXXX 函数中都一样，这里的共性暗示着我们可以为其建立一种抽象。&lt;&#x2F;p&gt;
&lt;p&gt;我们通过构建一种函数式风格的、语义化的链式调用来将这种共性抽象出来，它用起来大概是这样：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ts&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-ts &quot;&gt;&lt;code class=&quot;language-ts&quot; data-lang=&quot;ts&quot;&gt;&lt;span&gt;node&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;xxx &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;XXX&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;then_take&lt;&#x2F;span&gt;&lt;span&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;or_err&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;Expect a `xxx`&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里链式调用的关键是需要为我们的抽象定义一个类，这个类的实例方法会返回类实例本身，因此就可以再次调用另一个实例方法。我们将这个类称为 ParsingWorker，调用 next 函数会返回一个 ParsingWorker 的实例，该实例记录着当前的 Token，然后通过其上的实例方法执行具体的递归下降解析逻辑。&lt;&#x2F;p&gt;
&lt;p&gt;ParsingWorker 上主要有这几个字段：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;token&lt;&#x2F;code&gt; - 当前正在处理的 Token&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;result&lt;&#x2F;code&gt; - 每个 Worker 最终都有可能产生一个值（也可能不产生值），用来赋值给某个语法树节点的字段，这个值就是该 Worker 的 result&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;miss&lt;&#x2F;code&gt; - 布尔值，当 match 失败或预测集判定失败时置为真&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;实例方法主要有：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;match&lt;&#x2F;code&gt; - 判断当前 Token 是否匹配某个终结符&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;in_predict&lt;&#x2F;code&gt; - 判断当前 Token 是否在某个预测集里&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;then_take&lt;&#x2F;code&gt; - 此方法有一个可选的函数参数，当提供这个函数参数时，就执行它，把其返回值作为最终的 result，如果没有该参数，则根据当前 Token 来产生一个相应的 result&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;or_err&lt;&#x2F;code&gt; - 若 miss，则 throw 一个语法错误，若没有 miss，则返回 result&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;具体代码还有更多的逻辑细节，比如它还需要两个泛型参数，用来指定 result 的类型。这里就不展开详细说了，请查看 &lt;code&gt;src&#x2F;rd-parser.ts&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;基于 ParsingWorker 我们可以写出这样的 parse 函数：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ts&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-ts &quot;&gt;&lt;code class=&quot;language-ts&quot; data-lang=&quot;ts&quot;&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;function &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;parseProgram&lt;&#x2F;span&gt;&lt;span&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbcbb;&quot;&gt;Node&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;Program&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#d8dee9;&quot;&gt;node &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;createNode&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;Program&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;PROGRAM&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;or_err&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;Expect keyword `program`&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;  node&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;name &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;Identifier&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;ID&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;then_take&lt;&#x2F;span&gt;&lt;span&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;or_err&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;Expect an identifier&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;  node&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;declare &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;parseDeclarePart&lt;&#x2F;span&gt;&lt;span&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;  node&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span&gt;body &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;parseProgramBody&lt;&#x2F;span&gt;&lt;span&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;DOT&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;or_err&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;Expect `.`&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;node &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbcbb;&quot;&gt;Node&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;Program&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;function &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;parseTypeDecMore&lt;&#x2F;span&gt;&lt;span&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbcbb;&quot;&gt;Node&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;TypeDeclaration&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbcbb;&quot;&gt;null &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;TypeDeclaration&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbcbb;&quot;&gt;null&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;()
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;in_predict&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;then_take&lt;&#x2F;span&gt;&lt;span&gt;(() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;=&amp;gt; null&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;in_predict&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;then_take&lt;&#x2F;span&gt;&lt;span&gt;(parseTypeDecList)
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;or_err&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;Expect an identifier or keyword `var`, `procedure`, `begin`&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到代码更加简短，且更加语义化。&lt;&#x2F;p&gt;
&lt;p&gt;更高层级的抽象通常会带来额外的性能开销，这里的 ParsingWorker 跟直接在每个 parse 函数里写 if 相比会有新建实例和方法调用的额外开销，而编译器属于偏底层、性能敏感型的系统级程序，一个真实世界中 non-trivial 的编译器一定不会大量使用有额外开销的抽象。不过咱这是个玩具编译器，为了简洁性和语义化牺牲一点性能完全是可以接受的。&lt;&#x2F;p&gt;
&lt;p&gt;学习 Rust 时接触到一个叫做零开销抽象（zero-cost abstraction）的概念，指的是语言为你提供的抽象相比你自己手写的不会开销更大，相反只会更加高效，&amp;quot;What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.&amp;quot; 实现这一目标需要语言的精心设计和编译器的优化。Rust 尽力提供零开销抽象，使得在享受抽象带来的便利的同时不会有额外的性能开销，这对于性能敏感型程序是很重要的。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ll-1-jie-xi&quot;&gt;LL(1)解析&lt;&#x2F;h3&gt;
&lt;p&gt;LL(1) 解析和递归下降解析的思路是相似的，只不过是把递归的系统调用栈改为自己手动维护的符号栈而已。LL(1) 解析的主要算法请见 &lt;code&gt;src&#x2F;ll1-parser.ts&lt;&#x2F;code&gt; 中的 &lt;code&gt;parse&lt;&#x2F;code&gt; 函数。&lt;&#x2F;p&gt;
&lt;p&gt;问题在于，我们不仅要对 Token 序列是否合法进行判定，还需要在判定的过程中构建抽象语法树。为此除了符号栈之外，还需要一个语法树栈，以及用于处理表达式的操作数栈和操作符栈。&lt;&#x2F;p&gt;
&lt;p&gt;构建语法树的主要思路是，在将产生式右部压入符号栈时适时地进行一些额外的动作（这里称之为 action），比如创建一个相应的树节点并将其字段指针压入语法树栈，后面再生成节点时会从语法树栈中弹出一个这样的字段指针并将其赋值为该新建的节点，新节点的字段也相应地入栈。&lt;&#x2F;p&gt;
&lt;p&gt;JS&#x2F;TS 并没有指针类型，你无法取到一个值的“地址”，不过我们可以通过 JS 对象的 &lt;em&gt;可计算属性&lt;&#x2F;em&gt; 来模拟出字段指针的效果。JS 的可计算属性指的是对象的字段可以通过一个在运行时求值的字符串来访问（方括号语法）。语法树栈中的元素是一个二元组，包含一个节点本身的引用和该节点某个字段的字符串表示，这样就可以在后面弹栈后对这个字段进行赋值。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;ts&quot; style=&quot;background-color:#2e3440;color:#d8dee9;&quot; class=&quot;language-ts &quot;&gt;&lt;code class=&quot;language-ts&quot; data-lang=&quot;ts&quot;&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;type Pointer = &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbcbb;&quot;&gt;Record&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;unknown&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#d8dee9;&quot;&gt;astStack&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbcbb;&quot;&gt;Pointer&lt;&#x2F;span&gt;&lt;span&gt;[]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#d8dee9;&quot;&gt;node&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;font-weight:bold;color:#d8dee9;&quot;&gt;key&lt;&#x2F;span&gt;&lt;span&gt;] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;astStack&lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#88c0d0;&quot;&gt;pop&lt;&#x2F;span&gt;&lt;span&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;node[key] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#81a1c1;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;value&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eceff4;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里这个所谓的 Pointer 类型是不能保证类型安全的，需要手动保证字段和节点类型相匹配。&lt;&#x2F;p&gt;
&lt;p&gt;大部分的 action 都是“创建一个新节点，弹出语法树栈的栈顶元素，将其赋值成该新节点，将新节点的相应字段压入语法树栈”，我们将其抽象到一个 &lt;code&gt;link&lt;&#x2F;code&gt; 函数，表示“连接”到语法树。然后观察产生式，为每个产生式定义一个相应的 action（一个函数），大部分 action 都只是调用一次 &lt;code&gt;link&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;处理表达式时需要额外的考虑，因为需要处理操作符的优先级问题，所以不能简单地“link”，需要利用操作符栈和操作数栈来构建优先级正确的表达式节点，然后再“link”到语法树上。&lt;&#x2F;p&gt;
&lt;p&gt;观察产生式可以得到这样的结论：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;在处理 83 号产生式时开始一个表达式的处理&lt;&#x2F;li&gt;
&lt;li&gt;在处理 84 号产生式时结束一个表达式的处理，生成本次的表达式节点&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;观察产生式中有关表达式的其他一些性质，发现还需要 3 个标志变量：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;exp_should_link&lt;&#x2F;code&gt; - 表示本次表达式是否需要连接到语法树&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;exp_should_sibling&lt;&#x2F;code&gt; - 表示本次的表达式节点是否有兄弟节点&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;exp_not_over&lt;&#x2F;code&gt; - 表示本次的表达式是否还没有结束&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;在开始处理表达式时（83 号产生式的 action 处）我们为每个表达式记录一些信息，存在 &lt;code&gt;exp_info_stack&lt;&#x2F;code&gt; 中，这个栈的元素是一个三元组：在操作数栈中的开始位置、是否需要连接、是否有兄弟节点。&lt;&#x2F;p&gt;
&lt;p&gt;然后在和表达式相关的产生式的 action 中对这些标志变量以及操作数栈和操作符栈进行相应的操作就可以正确地构造出优先级正确的表达式节点了，注意在处理表达式时也会暂时性地用到语法树栈。具体的处理逻辑请看代码。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yu-yi-fen-xi&quot;&gt;语义分析&lt;&#x2F;h2&gt;
&lt;p&gt;完成语法分析后得到了语法树，相应的语法错误也得以检测，下一个步骤是语义分析。由于本项目只完成编译器前端部分，所以语义分析模块只检测语义错误，没有别的输出。&lt;&#x2F;p&gt;
&lt;p&gt;SNL 的语义错误包括：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;标识符重复定义&lt;&#x2F;li&gt;
&lt;li&gt;标识符未声明&lt;&#x2F;li&gt;
&lt;li&gt;标识符未非期望的标识符类型&lt;&#x2F;li&gt;
&lt;li&gt;数组定义时下界大于上界（教材里很奇怪地把这个错误叫做数组下标越界，但真正的“数组下标越界”应该一个运行时错误，而不是编译时错误）&lt;&#x2F;li&gt;
&lt;li&gt;数组索引不是整型，记录类型的域变量引用不合法&lt;&#x2F;li&gt;
&lt;li&gt;赋值语句两侧类型不匹配&lt;&#x2F;li&gt;
&lt;li&gt;赋值语句左侧不是变量标识符&lt;&#x2F;li&gt;
&lt;li&gt;过程调用中形实参类型不匹配&lt;&#x2F;li&gt;
&lt;li&gt;过程调用中形实参个数不匹配&lt;&#x2F;li&gt;
&lt;li&gt;过程调用处的标识符不是过程标识符&lt;&#x2F;li&gt;
&lt;li&gt;表达式运算符两侧分量类型不匹配&lt;&#x2F;li&gt;
&lt;li&gt;if 和 while 语句的条件部分不是布尔型（但其实这条在语法分析阶段就得以保证了，SNL 的文法保证了条件部分只能是比较表达式）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;fu-hao-biao&quot;&gt;符号表&lt;&#x2F;h3&gt;
&lt;p&gt;语义分析的关键在于构造符号表， 记录程序中出现的所有标识符及它的“种类”信息，分为类型标识符、变量标识符和过程标识符，符号表项称为 &lt;code&gt;TableItem&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;类型标识符需要以某种形式记录它的“类型”，变量标识符也需要，另外还需要记录变量是按值访问还是按引用访问，过程标识符则需要记录参数的信息，一个参数可以当作一个变量标识符来对待。&lt;&#x2F;p&gt;
&lt;p&gt;“类型”信息使用 &lt;code&gt;Ty&lt;&#x2F;code&gt; 来表示，整形、字符型、布尔型属于原始类型，只需要单独的一个实例就可以，array 和 record 类型则每个类型都不同，需要记录自己的额外信息，array 需要记录它的元素的“类型”，record 需要记录它的域的相关信息。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;TableItem&lt;&#x2F;code&gt; 和 &lt;code&gt;Ty&lt;&#x2F;code&gt; 的具体定义请见 &lt;code&gt;src&#x2F;sem-analyzer.ts&lt;&#x2F;code&gt;，当处理程序时，每个作用域会有一个符号表，整个程序有一个 &lt;code&gt;Ty&lt;&#x2F;code&gt; 表（一个数组）来记录所有出现的“类型”。&lt;&#x2F;p&gt;
&lt;p&gt;语义分析在分析程序的声明部分时建立符号表，在分析程序的语句部分时遇到标识符则查找符号表，在这个过程中进行类型检查和其他语义错误检测。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zuo-yong-yu&quot;&gt;作用域&lt;&#x2F;h3&gt;
&lt;p&gt;语义分析的一个关键在于“作用域”的处理，SNL 支持嵌套过程定义，每个过程内部都算作一个新的作用域，在这个作用域里可能会存在作用域遮蔽效应，即本地标识符定义覆盖了外部作用域中的标识符定义。&lt;&#x2F;p&gt;
&lt;p&gt;每个作用域都有一个符号表，这些符号表组织在一个栈中。&lt;&#x2F;p&gt;
&lt;p&gt;代码实现上语义分析分为 build 和 check 两个主要动作，在声明部分（主程序的和每个过程的）进行构建&#x2F;维护符号表（build），在语句部分进行相应的语义检查（check），遇到过程定义时递归地向下处理，这时会新建一个作用域（nest in），处理完一个过程后销毁该作用域（nest out）&lt;&#x2F;p&gt;
&lt;p&gt;check 可以分为语句检查、表达式检查和变量检查，在 check 阶段只需要针对上面列出的语义错误在相应的位置写具体的逻辑就好。具体逻辑请看代码，注意代码里的 &lt;code&gt;Scope&lt;&#x2F;code&gt; 类表示整个作用域集合，而不是单独的一层作用域。&lt;&#x2F;p&gt;
&lt;p&gt;到这里，这个玩具编译器（前端）就基本完成了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ming-ling-xing-jie-mian&quot;&gt;命令行界面&lt;&#x2F;h2&gt;
&lt;p&gt;再来做一下命令行界面，命令称为 &lt;code&gt;snlc&lt;&#x2F;code&gt; (SNL Compiler)，第一个参数是需要编译的 snl 文件路径，另外有这些标志参数：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--set&lt;&#x2F;code&gt; 打印预测集&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--table&lt;&#x2F;code&gt; 打印预测表&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--token&lt;&#x2F;code&gt; 打印 Token 列表&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--ast&lt;&#x2F;code&gt; 打印抽象语法树&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--ll&lt;&#x2F;code&gt; 使用 LL(1) parser，默认是递归下降 parser&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;pretty-print&quot;&gt;Pretty Print&lt;&#x2F;h3&gt;
&lt;p&gt;还可以让命令行输出更加“用户友好”一些。&lt;&#x2F;p&gt;
&lt;p&gt;打印错误信息时模仿了 Rust 编译器的错误输出风格，会显示行号和那一行的代码，指出错误的位置。&lt;&#x2F;p&gt;
&lt;p&gt;打印 AST 时则使用了 Linux 的 tree 命名风格的树形输出，这个效果的实现关键在于递归打印时维护一个 prefix 栈。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;github.com&#x2F;isunjn&#x2F;snlc&#x2F;blob&#x2F;main&#x2F;docs&#x2F;example.png?raw=true&quot; alt=&quot;样例输出截图&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h2&gt;
&lt;p&gt;总的来说，这确实是一个大学生课设级别的玩具语言的玩具编译器实现，还只有前端部分，但真正动手实现一个编译器仍然让我学到了很多东西，也让我体会到了编译器的奥妙。等之后有时间了想再系统地学一学相关的知识，看一下那本编译原理龙书，还有那本《Crafting Interpreters》，可能要等到秋招之后了。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="zh-CN">
		<title>Serene - 一款简洁优雅的博客主题</title>
		<published>2022-01-19T00:00:00+00:00</published>
		<updated>2022-04-19T00:00:00+00:00</updated>
        <summary>&lt;p&gt;追求形式确实比追求内容要容易许多，有很多想写&#x2F;计划写博客的人文章还没写多少，却把时间都花在了折腾写作工具、选主题、改样式之上……我就是其中之一，实在惭愧 😢&lt;&#x2F;p&gt;
&lt;p&gt;因为多少有一点强迫症，看了好多别的博客主题，都不是很满意，自己就动手写了一个。其实写这种静态的博客主题主要是写 CSS，并没有太多的&#x27;技术含量&#x27;，主要还是审美和设计，过程中思考了一些关于博客内容和样式的东西，觉得还是值得说一说的。&lt;&#x2F;p&gt;
</summary>
		<link href="https://isunjn.me/blog/serene-theme/" type="text/html"/>
		<id>https://isunjn.me/blog/serene-theme/</id>
		<content type="html">&lt;p&gt;追求形式确实比追求内容要容易许多，有很多想写&#x2F;计划写博客的人文章还没写多少，却把时间都花在了折腾写作工具、选主题、改样式之上……我就是其中之一，实在惭愧 😢&lt;&#x2F;p&gt;
&lt;p&gt;因为多少有一点强迫症，看了好多别的博客主题，都不是很满意，自己就动手写了一个。其实写这种静态的博客主题主要是写 CSS，并没有太多的&#x27;技术含量&#x27;，主要还是审美和设计，过程中思考了一些关于博客内容和样式的东西，觉得还是值得说一说的。&lt;&#x2F;p&gt;
&lt;span id=&quot;continue-reading&quot;&gt;&lt;&#x2F;span&gt;
&lt;p&gt;主题取名 serene，有平静、清澈、晴朗之意。&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;isunjn&#x2F;serene&quot;&gt;GitHub&lt;&#x2F;a&gt; | &lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;serene-demo-site.vercel.app&quot;&gt;Demo&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;很多博客（主题）会给人一种花里胡哨的感觉，每次看到有的博客站点一堆与内容无关的图片等元素时都有点反感，加一点还觉得活泼有特点，加一堆就感觉有点主次不分了。当然个人网站&#x2F;博客有风格一点完全无可厚非，只是我个人更喜欢简洁一点的。个人认为博客还是应当以内容为主，突出文字，少一些对阅读的干扰。&lt;&#x2F;p&gt;
&lt;p&gt;Serene 围绕“阅读”的一些功能考虑：&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ce-lan-mu-lu&quot;&gt;侧栏目录&lt;&#x2F;h2&gt;
&lt;p&gt;我个人看文章喜欢先扫一眼标题大纲，有个大概的概念，可以了解这篇文章要说什么，很多博客（主题）都没有。&lt;&#x2F;p&gt;
&lt;p&gt;Serene 的文章主体是居中的，目录在文章右侧，是 sticky 的，很多有目录的博客（主题）的目录不是 sticky 的，显示在页面顶部，往下划就看不到了，比没有目录还让人抓狂。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yue-du-jin-du-tiao&quot;&gt;阅读进度条&lt;&#x2F;h2&gt;
&lt;p&gt;Serene 可以设置显示一个在 header 下方的阅读进度条。加这个功能是因为我自己在阅读一些博客文章的时候会希望对进度和时间有个大概的把握，网页自身的进度条通常并不能提供文章本身的进度信息，因为页面下方通常会有评论区等。一些博客（主题）会显示一个根据字数得到的估计阅读时间，这个我感觉参考意义不大，每个人阅读速度、习惯、目的以及文章本身的类型其实都不太一样，简单显示一下字数可能还比较靠谱。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;an-se-mo-shi&quot;&gt;暗色模式&lt;&#x2F;h2&gt;
&lt;p&gt;Serene 的暗色模式可以做到：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;第一次访问时根据浏览器偏好设置亮&#x2F;暗色&lt;&#x2F;li&gt;
&lt;li&gt;手动切换亮&#x2F;暗色&lt;&#x2F;li&gt;
&lt;li&gt;页面在偏好更改时会自动跟随切换亮&#x2F;暗色（不过这个用处不是很大）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;guo-shi-ti-xing&quot;&gt;过时提醒&lt;&#x2F;h2&gt;
&lt;p&gt;一些技术向的文章可能会有较强的时效性，文章的部分内容可能一段时间后就会过时&#x2F;不再适用。Serene 可以设置在若干天后在文章顶部显示一条（可能）过时提醒，是否过时以及多长时间后过时可以每篇文章单独设置。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;callout&quot;&gt;Callout&lt;&#x2F;h2&gt;
&lt;p&gt;你可能经常在一些文档类站点看到一些诸如 info、important、tip、warning 等的起强调作用、背景颜色不同的文字块，这个被叫做 callout 或 admonition。Serene 通过 Zola 提供的 shortcodes 特性支持了这个，效果如示例站点的&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;serene-demo-site.vercel.app&#x2F;blog&#x2F;admonitions&#x2F;&quot;&gt;这个页面&lt;&#x2F;a&gt;所示，可以给文章增加一些强调或趣味性。&lt;&#x2F;p&gt;
&lt;blockquote class=&quot;note info&quot;&gt;
    &lt;i class=&quot;ri-information-line ri-lg&quot;&gt;&lt;&#x2F;i&gt;
    &lt;div class=&quot;content&quot;&gt;
        
        &lt;p&gt;Here&#x27;s some relevant information about ...&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
&lt;&#x2F;blockquote&gt;&lt;blockquote class=&quot;note important&quot;&gt;
    &lt;i class=&quot;ri-error-warning-line ri-lg&quot;&gt;&lt;&#x2F;i&gt;
    &lt;div class=&quot;content&quot;&gt;
        
        &lt;p&gt;It&#x27;s important to remember that ...&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
&lt;&#x2F;blockquote&gt;&lt;blockquote class=&quot;note warning&quot;&gt;
    &lt;i class=&quot;ri-alarm-warning-line ri-lg&quot;&gt;&lt;&#x2F;i&gt;
    &lt;div class=&quot;content&quot;&gt;
        
        &lt;p&gt;BREAKING !!!&lt;&#x2F;p&gt;

    &lt;&#x2F;div&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;不过如果别人是用 RSS 阅读你的包含 callout 的文章，这些文字块会显示为普通的 &lt;code&gt;&amp;lt;blockquote&amp;gt;&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;qi-ta-yi-xie-xi-jie&quot;&gt;其他一些细节&lt;&#x2F;h2&gt;
&lt;p&gt;分类、标签、返回顶部按钮、评论支持、流量统计工具支持等博客站点常见的功能也都是有的。另外还有一些细节：毛玻璃效果、一致的主题色、图片缩放、平滑滚动、CC 协议声明等。&lt;&#x2F;p&gt;
&lt;p&gt;另外我对 Gitalk 的 CSS 做了一些修改以便它可以适配暗色模式以及跟随主题色。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;希望你不要像我一样想写博客却在这些不是最重要的事情上花了太多时间，还是先写点东西出来吧……&lt;&#x2F;p&gt;
&lt;p&gt;如果这个主题能帮到别人少折腾的话，就再好不过了 🥲&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="zh-CN">
		<title>Say Hello Again</title>
		<published>2021-10-21T00:00:00+00:00</published>
		<updated>2021-10-21T00:00:00+00:00</updated>
		<link href="https://isunjn.me/blog/say-hello-again/" type="text/html"/>
		<id>https://isunjn.me/blog/say-hello-again/</id>
		<content type="html">&lt;p&gt;这是博客的第一篇文章。我很喜欢个人博客这种形式，除了通过其他人的博客学了很多技术相关的东西之外，个人博客往往还会有一些作者本人的经历、思考和感悟，有一种独特的人文关怀感，曾带给我许多感动。&lt;&#x2F;p&gt;
&lt;p&gt;在茫茫的互联网上拥有一个属于自己的空间可以记录、表达、分享，确实很吸引人，不过很多人(就比如我)往往过分注重形式，忽视了博客最重要的其实是有价值的内容，是持续的思考和写作。可能因为有一点强迫症，我搭建过好几次博客，用静态网站生成器做一个博客站点很容易，但是总感觉不是我想要的样子，自己当时也没有内容才是关键的觉悟，没有写下些什么，就不了了之了。&lt;&#x2F;p&gt;
&lt;p&gt;最终，我还是按自己心中的想法做了&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;isunjn&#x2F;serene&quot;&gt;一个博客主题&lt;&#x2F;a&gt;... 静态网站生成器用的是 &lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;getzola.org&quot;&gt;Zola&lt;&#x2F;a&gt;，它是用 Rust 写的，好像每种语言都有相应的 &lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;jamstack.org&#x2F;generators&#x2F;&quot;&gt;Static Site Generator&lt;&#x2F;a&gt;，选 Zola 也没什么特殊的理由，只是看文档感觉比较容易上手，各种功能也都有，虽然 Hexo 和 Hugo 用的人更多一些。主题取名 Serene，设计较简洁，围绕阅读做了一些特殊的考虑，我希望这是一个以内容为主的博客主题。书写是为了更好的思考，希望未来能产出一些有价值的内容。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;isunjn&#x2F;isunjn.github.io&#x2F;img&#x2F;202204191340939.jpg&quot; alt=&quot;img&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;这张图里是我人生第一个 Hello, World, 是在高考结束后的那个暑假写的。&lt;&#x2F;p&gt;
&lt;p&gt;Hope this traditional incantation can also help me with writing blog :)&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>